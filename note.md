# 手写数字识别
开发环境：windows

项目名称：手写数字识别

## 项目介绍
本项目主要是学习在windows环境下学习CNN神经网络的全流程。
本项目一切过程尽量贴近实际，在可能的情况下尽可能使用更详细的代码实现，不用封装好的函数。



1. 数据集学习

    使用MNIST数据集，学会读取内部的内容，转化成可是图片或者内容。
    
    学习构建自己的手写数字数据集

2. 神经网络的学习

    以pytorch为学习框架，设计CNN框架，使用函数搭建CNN。

3. 如何训练、测试

    学习如何使用代码实现训练和测试，在代码层面上有无具体的区别

4. 如何应用

    尝试使用USB摄像头对本神经网络进行实际实践

## 数据集
### MNIST

**压缩文件介绍**

使用tar打包归档的包叫做tar包，以.tar结尾

使用gzip压缩的文件，以.gz结尾

日常使用中，特别是对目录及里面的文件，一般先进行tar打包再进行gzip压缩，此时的文件以.tar.gz结尾

**解压文件**

使用gzip命令将文件解压

```commandline
gzip -d *.gz
```

**读取文件内容**

首先，需要知道这几个文件里的内容。其次还需要知道文件的组成方式。
如果想要阅读英语的可以查看[THE MNIST DATABASE](http://yann.lecun.com/exdb/mnist/)。
在网站中的FILE FORMATS FOR THE MNIST DATABASE标题下有着对数据库的详细介绍。

数据存储在非常简单的文件格式中，专为存储矢量和多维矩阵而设计。有关此格式的一般信息在本页末尾提供，但您无需阅读即可使用数据文件。

文件中的所有整数都以大多数非英特尔处理器使用的 MSB 第一（高端）格式存储。英特尔处理器和其他低端计算机的用户必须翻转标头的字节。

这四个文件的内容分别为：

train-images-idx3-ubyte: 训练集图像

train-labels-idx1-ubyte: 训练集图像标签

t10k-images-idx3-ubyte:  测试集图像

t10k-labels-idx1-ubyte: 测试集图像标签

训练集共有60000个样本，测试集共有10000个样本。

下面说明四个文件的文件结构

TRAINING SET LABEL FILE (train-labels-idx1-ubyte):

| [offset] | [type]         | [value]          | [description]            |
|----------|----------------|------------------|--------------------------|
| 0000     | 32 bit integer | 0x00000801(2049) | magic number (MSB first) |
| 0004     | 32 bit integer | 60000            | number of items          |
| 0008     | unsigned byte  | ??               | label                    |
| 0009     | unsigned byte  | ??               | label                    |
| ...      | ...            | ...              | ...                      |
| xxxx     | unsigned byte  | ??               | label                    |

标签的label在0-9之间

TRAINING SET IMAGE FILE (train-images-idx3-ubyte):

| [offset] | [type]         | [value]          | [description]            |
|----------|----------------|------------------|--------------------------|
| 0000     | 32 bit integer | 0x00000801(2049) | magic number (MSB first) |
| 0004     | 32 bit integer | 60000            | number of images         |
| 0008     | 32 bit integer | 28               | number of rows           |
| 00012    | 32 bit integer | 28               | number of columns        |
| 00016    | unsigned byte  | ??               | pixel                    |
| 00017    | unsigned byte  | ??               | pixel                    |
| ...      | ...            | ...              | ...                      |
| xxxx     | unsigned byte  | ??               | pixel                    |

像素是逐行排列的，像素的取值范围在0-255。0代表背景（白色），1代表前景（黑色）。

测试集的文件组织方式和训练集相同

其次，需要在python中编程。

**编程逻辑如下：**

**读取图片数据集思路**

打开文件。将文件读取为二进制数据。

通过struct包。读取其中的数据，先独立读取文件的头部的魔数、一些文件的内部的参数。
再读取后部的图片文件，将图片集存储为np的一个三维数组。

**读取标签数据集思路**

打开文件。将文件读取为二进制数据。

通过struct包，读取出头部的魔术和标签数量。
在将后面的标签的值存储在一个数组中即可。


### 自己制作数据集
经过搜索和思考之后，此种数据集不需要复杂的数据标注工具，只需要一个图片文件的集合，和与之图片顺序
相对应的标签名即可构成数据集。

## Dataset的制作



## 神经网络

LeNet-5：是Yann LeCun在1998年设计的用于手写数字识别的卷积神经网络，
LeNet-5是一个应用于图像分类问题的卷积神经网络，
其学习目标是从一系列由32×32×1灰度图像表示的手写数字中识别和区分0-9。

由于是初次学习神经网络，我们就都从最初的方式开始学习，既可以打下良好的基础，
同时学习的复杂程度也不会非常高。

所以接下来根据LeNet-5的结构设计我们的手写数字识别的卷积神经网络。

note：

想要拜读文章的可以走[Gradient-based learning applied to document recognition](https://ieeexplore.ieee.org/document/726791)
如果要下载文章可以访问（贴上公众号链接）


### 卷积神经网络的设计

首先我们介绍LeNet-5的网络结构

输入INPUT：32*32

操作：卷积 卷积核大小=5*5 卷积步长=1 卷积核的个数=6

第一层C1（featuremap,特征图）：28*28*6

操作：降采样 最大池化 大小=2*2 步长=2

乘以 可训练的系数；加上 一个可训练的偏置；再通过一个sigmoidal function

第二层S2：14*14*6

操作：卷积 卷积核大小=5*5 卷积步长=1 卷积核的个数=16

注意，采用交错卷积的方法。下图中，0-15为卷积操作的卷积核；0-5为C1层对应的特征图；对应画
×的地方为两者进行卷积操作

![](.\\img\\1.png)

第三层C3：10*10*16

操作：降采样 最大池化 大小=2*2 步长=2

与C1-S2的步骤相同

第四层S4：5*5*16

操作：全连接 

第五层C5：120*1*1

操作：全连接

第六层C6：84*1*1

操作：全连接

最终输出OUTPUT：10*1*1

### 卷积神经网络的搭建

## 神经网络的训练以及测试



# 知识集合

## LSB、MSB和大小端

MSB（Most Significant Bit）：最高有效位，二进制中代表最高值的比特位，这一位对数值的影响最大。

LSB（Least Significant Bit）：最低有效位，二进制中代表最低值的比特位

大端模式（Big-Endian）：数据的高位字节放到内存的低地址端，低位字节放到内存的高地址端。

小端模式（Little-Endian）：数据的低位字节放到内存的低地址端，高位字节放到内存的高地址端。

示例：假如现在有一个32位int型数0x12345678。这个数的MSB为0x12，这个数的LSB 为0x78。

OP0表示一个32位数据的最高字节MSB（Most Significant Byte），使用OP3表示一个32位数据最低字节LSB（Least Significant Byte）。

| 地址偏移      | 大端模式    | 小端模式     |
|-----------|---------|----------|
| 0x00      | 12（OP0） | 78（OP3）  | 
| 0x01      | 34（OP1） | 56（OP2）  | 
| 0x02      | 56（OP2） | 34（OP1）  | 
| 0x03      | 78（OP3） | 12（OP0）  | 

## LINUX压缩文件介绍
使用tar打包归档的包叫做tar包，以.tar结尾

使用gzip压缩的文件，以.gz结尾

日常使用中，特别是对目录及里面的文件，一般先进行tar打包再进行gzip压缩，此时的文件以.tar.gz结尾

## python知识内容

### 注释

一行注释：井号

多行注释：一对三个单引号或三个双引号

### print输出
print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 `end=""`：

`print('输出字符串' %(格式化输出内容))`


### 文件操作

Python `open()` 方法用于打开一个文件，并返回文件对象。

注意：使用 `open()` 方法一定要保证关闭文件对象，即调用 `close()` 方法。

`open()` 函数常用形式是接收两个参数：文件名(file)和模式(mode)。

默认为文本模式，如果要以二进制模式打开，加上 `b` 。

### file 对象常用的函数:

**概述**

`read()` 方法用于从文件读取指定的字符数（文本模式 `t`）或字节数（二进制模式 `b`），如果未给定参数 `size` 或 `size` 为负数则读取文件所有内容。

**语法**

`fileObject.read([size])`

**参数**

size -- 从文件中读取的字符数（文本模式）或字节数（二进制模式），默认为 -1，表示读取整个文件。

**返回值**

返回从字符串中读取的字节。


